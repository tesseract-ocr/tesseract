{"version":3,"sources":["../../../src/lib/metadata/metadata.tsx"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\nimport type { GetDynamicParamFromSegment } from '../../server/app-render/app-render'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { CreateServerParamsForMetadata } from '../../server/request/params'\n\nimport { cache, cloneElement } from 'react'\nimport {\n  AppleWebAppMeta,\n  FormatDetectionMeta,\n  ItunesMeta,\n  BasicMeta,\n  ViewportMeta,\n  VerificationMeta,\n  FacebookMeta,\n} from './generate/basic'\nimport { AlternatesMetadata } from './generate/alternate'\nimport {\n  OpenGraphMetadata,\n  TwitterMetadata,\n  AppLinksMeta,\n} from './generate/opengraph'\nimport { IconsMetadata } from './generate/icons'\nimport {\n  resolveMetadataItems,\n  accumulateMetadata,\n  accumulateViewport,\n  type MetadataErrorType,\n} from './resolve-metadata'\nimport { MetaFilter } from './generate/meta'\nimport type {\n  ResolvedMetadata,\n  ResolvedViewport,\n} from './types/metadata-interface'\nimport { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback'\nimport type { MetadataContext } from './types/resolvers'\nimport type { WorkStore } from '../../server/app-render/work-async-storage.external'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n} from './metadata-constants'\n\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({\n  tree,\n  searchParams,\n  metadataContext,\n  getDynamicParamFromSegment,\n  appUsingSizeAdjustment,\n  errorType,\n  createServerParamsForMetadata,\n  workStore,\n  MetadataBoundary,\n  ViewportBoundary,\n}: {\n  tree: LoaderTree\n  searchParams: Promise<ParsedUrlQuery>\n  metadataContext: MetadataContext\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  appUsingSizeAdjustment: boolean\n  errorType?: MetadataErrorType | 'redirect'\n  createServerParamsForMetadata: CreateServerParamsForMetadata\n  workStore: WorkStore\n  MetadataBoundary: (props: { children: React.ReactNode }) => React.ReactNode\n  ViewportBoundary: (props: { children: React.ReactNode }) => React.ReactNode\n}): [React.ComponentType, () => Promise<void>] {\n  function MetadataRoot() {\n    return (\n      <>\n        <MetadataBoundary>\n          <Metadata />\n        </MetadataBoundary>\n        <ViewportBoundary>\n          <Viewport />\n        </ViewportBoundary>\n        {appUsingSizeAdjustment ? (\n          <meta name=\"next-size-adjust\" content=\"\" />\n        ) : null}\n      </>\n    )\n  }\n\n  async function viewport() {\n    return getResolvedViewport(\n      tree,\n      searchParams,\n      getDynamicParamFromSegment,\n      createServerParamsForMetadata,\n      workStore,\n      errorType\n    )\n  }\n\n  async function Viewport() {\n    try {\n      return await viewport()\n    } catch (error) {\n      if (!errorType && isHTTPAccessFallbackError(error)) {\n        try {\n          return await getNotFoundViewport(\n            tree,\n            searchParams,\n            getDynamicParamFromSegment,\n            createServerParamsForMetadata,\n            workStore\n          )\n        } catch {}\n      }\n      // We don't actually want to error in this component. We will\n      // also error in the MetadataOutlet which causes the error to\n      // bubble from the right position in the page to be caught by the\n      // appropriate boundaries\n      return null\n    }\n  }\n  Viewport.displayName = VIEWPORT_BOUNDARY_NAME\n\n  async function metadata() {\n    return getResolvedMetadata(\n      tree,\n      searchParams,\n      getDynamicParamFromSegment,\n      metadataContext,\n      createServerParamsForMetadata,\n      workStore,\n      errorType\n    )\n  }\n\n  async function Metadata() {\n    try {\n      return await metadata()\n    } catch (error) {\n      if (!errorType && isHTTPAccessFallbackError(error)) {\n        try {\n          return await getNotFoundMetadata(\n            tree,\n            searchParams,\n            getDynamicParamFromSegment,\n            metadataContext,\n            createServerParamsForMetadata,\n            workStore\n          )\n        } catch {}\n      }\n      // We don't actually want to error in this component. We will\n      // also error in the MetadataOutlet which causes the error to\n      // bubble from the right position in the page to be caught by the\n      // appropriate boundaries\n      return null\n    }\n  }\n  Metadata.displayName = METADATA_BOUNDARY_NAME\n\n  async function getMetadataAndViewportReady(): Promise<void> {\n    await viewport()\n    await metadata()\n    return undefined\n  }\n\n  return [MetadataRoot, getMetadataAndViewportReady]\n}\n\nconst getResolvedMetadata = cache(getResolvedMetadataImpl)\nasync function getResolvedMetadataImpl(\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  metadataContext: MetadataContext,\n  createServerParamsForMetadata: CreateServerParamsForMetadata,\n  workStore: WorkStore,\n  errorType?: MetadataErrorType | 'redirect'\n): Promise<React.ReactNode> {\n  const errorConvention = errorType === 'redirect' ? undefined : errorType\n\n  const metadataItems = await resolveMetadataItems(\n    tree,\n    searchParams,\n    errorConvention,\n    getDynamicParamFromSegment,\n    createServerParamsForMetadata,\n    workStore\n  )\n  const elements: Array<React.ReactNode> = createMetadataElements(\n    await accumulateMetadata(metadataItems, metadataContext)\n  )\n  return (\n    <>\n      {elements.map((el, index) => {\n        return cloneElement(el as React.ReactElement, { key: index })\n      })}\n    </>\n  )\n}\n\nconst getNotFoundMetadata = cache(getNotFoundMetadataImpl)\nasync function getNotFoundMetadataImpl(\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  metadataContext: MetadataContext,\n  createServerParamsForMetadata: CreateServerParamsForMetadata,\n  workStore: WorkStore\n): Promise<React.ReactNode> {\n  const notFoundErrorConvention = 'not-found'\n  const notFoundMetadataItems = await resolveMetadataItems(\n    tree,\n    searchParams,\n    notFoundErrorConvention,\n    getDynamicParamFromSegment,\n    createServerParamsForMetadata,\n    workStore\n  )\n\n  const elements: Array<React.ReactNode> = createMetadataElements(\n    await accumulateMetadata(notFoundMetadataItems, metadataContext)\n  )\n  return (\n    <>\n      {elements.map((el, index) => {\n        return cloneElement(el as React.ReactElement, { key: index })\n      })}\n    </>\n  )\n}\n\nconst getResolvedViewport = cache(getResolvedViewportImpl)\nasync function getResolvedViewportImpl(\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  createServerParamsForMetadata: CreateServerParamsForMetadata,\n  workStore: WorkStore,\n  errorType?: MetadataErrorType | 'redirect'\n): Promise<React.ReactNode> {\n  const errorConvention = errorType === 'redirect' ? undefined : errorType\n\n  const metadataItems = await resolveMetadataItems(\n    tree,\n    searchParams,\n    errorConvention,\n    getDynamicParamFromSegment,\n    createServerParamsForMetadata,\n    workStore\n  )\n  const elements: Array<React.ReactNode> = createViewportElements(\n    await accumulateViewport(metadataItems)\n  )\n  return (\n    <>\n      {elements.map((el, index) => {\n        return cloneElement(el as React.ReactElement, { key: index })\n      })}\n    </>\n  )\n}\n\nconst getNotFoundViewport = cache(getNotFoundViewportImpl)\nasync function getNotFoundViewportImpl(\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  createServerParamsForMetadata: CreateServerParamsForMetadata,\n  workStore: WorkStore\n): Promise<React.ReactNode> {\n  const notFoundErrorConvention = 'not-found'\n  const notFoundMetadataItems = await resolveMetadataItems(\n    tree,\n    searchParams,\n    notFoundErrorConvention,\n    getDynamicParamFromSegment,\n    createServerParamsForMetadata,\n    workStore\n  )\n\n  const elements: Array<React.ReactNode> = createViewportElements(\n    await accumulateViewport(notFoundMetadataItems)\n  )\n  return (\n    <>\n      {elements.map((el, index) => {\n        return cloneElement(el as React.ReactElement, { key: index })\n      })}\n    </>\n  )\n}\n\nfunction createMetadataElements(metadata: ResolvedMetadata) {\n  return MetaFilter([\n    BasicMeta({ metadata }),\n    AlternatesMetadata({ alternates: metadata.alternates }),\n    ItunesMeta({ itunes: metadata.itunes }),\n    FacebookMeta({ facebook: metadata.facebook }),\n    FormatDetectionMeta({ formatDetection: metadata.formatDetection }),\n    VerificationMeta({ verification: metadata.verification }),\n    AppleWebAppMeta({ appleWebApp: metadata.appleWebApp }),\n    OpenGraphMetadata({ openGraph: metadata.openGraph }),\n    TwitterMetadata({ twitter: metadata.twitter }),\n    AppLinksMeta({ appLinks: metadata.appLinks }),\n    IconsMetadata({ icons: metadata.icons }),\n  ])\n}\n\nfunction createViewportElements(viewport: ResolvedViewport) {\n  return MetaFilter([ViewportMeta({ viewport: viewport })])\n}\n"],"names":["createMetadataComponents","tree","searchParams","metadataContext","getDynamicParamFromSegment","appUsingSizeAdjustment","errorType","createServerParamsForMetadata","workStore","MetadataBoundary","ViewportBoundary","MetadataRoot","Metadata","Viewport","meta","name","content","viewport","getResolvedViewport","error","isHTTPAccessFallbackError","getNotFoundViewport","displayName","VIEWPORT_BOUNDARY_NAME","metadata","getResolvedMetadata","getNotFoundMetadata","METADATA_BOUNDARY_NAME","getMetadataAndViewportReady","undefined","cache","getResolvedMetadataImpl","errorConvention","metadataItems","resolveMetadataItems","elements","createMetadataElements","accumulateMetadata","map","el","index","cloneElement","key","getNotFoundMetadataImpl","notFoundErrorConvention","notFoundMetadataItems","getResolvedViewportImpl","createViewportElements","accumulateViewport","getNotFoundViewportImpl","MetaFilter","BasicMeta","AlternatesMetadata","alternates","ItunesMeta","itunes","FacebookMeta","facebook","FormatDetectionMeta","formatDetection","VerificationMeta","verification","AppleWebAppMeta","appleWebApp","OpenGraphMetadata","openGraph","TwitterMetadata","twitter","AppLinksMeta","appLinks","IconsMetadata","icons","ViewportMeta"],"mappings":"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"}