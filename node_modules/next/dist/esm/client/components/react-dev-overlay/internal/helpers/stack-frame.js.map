{"version":3,"sources":["../../../../../../src/client/components/react-dev-overlay/internal/helpers/stack-frame.ts"],"sourcesContent":["import type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport type { OriginalStackFrameResponse } from '../../server/shared'\nimport {\n  isWebpackInternalResource,\n  formatFrameSourceFile,\n} from './webpack-module-path'\nexport interface OriginalStackFrame extends OriginalStackFrameResponse {\n  error: boolean\n  reason: string | null\n  external: boolean\n  ignored: boolean\n  sourceStackFrame: StackFrame\n}\n\nfunction getOriginalStackFrame(\n  source: StackFrame,\n  type: 'server' | 'edge-server' | null,\n  isAppDir: boolean,\n  errorMessage: string\n): Promise<OriginalStackFrame> {\n  async function _getOriginalStackFrame(): Promise<OriginalStackFrame> {\n    const params = new URLSearchParams()\n    params.append('isServer', String(type === 'server'))\n    params.append('isEdgeServer', String(type === 'edge-server'))\n    params.append('isAppDirectory', String(isAppDir))\n    params.append('errorMessage', errorMessage)\n    for (const key in source) {\n      params.append(key, ((source as any)[key] ?? '').toString())\n    }\n\n    const controller = new AbortController()\n    const tm = setTimeout(() => controller.abort(), 3000)\n    const res = await self\n      .fetch(\n        `${\n          process.env.__NEXT_ROUTER_BASEPATH || ''\n        }/__nextjs_original-stack-frame?${params.toString()}`,\n        { signal: controller.signal }\n      )\n      .finally(() => {\n        clearTimeout(tm)\n      })\n    if (!res.ok || res.status === 204) {\n      return Promise.reject(new Error(await res.text()))\n    }\n\n    const body: OriginalStackFrameResponse = await res.json()\n    return {\n      error: false,\n      reason: null,\n      external: false,\n      sourceStackFrame: source,\n      originalStackFrame: body.originalStackFrame,\n      originalCodeFrame: body.originalCodeFrame || null,\n      sourcePackage: body.sourcePackage,\n      ignored: body.originalStackFrame?.ignored || false,\n    }\n  }\n\n  // TODO: merge this section into ignoredList handling\n  if (\n    source.file === 'file://' ||\n    source.file?.match(/^node:/) ||\n    source.file?.match(/https?:\\/\\//)\n  ) {\n    return Promise.resolve({\n      error: false,\n      reason: null,\n      external: true,\n      sourceStackFrame: source,\n      originalStackFrame: null,\n      originalCodeFrame: null,\n      sourcePackage: null,\n      ignored: true,\n    })\n  }\n\n  return _getOriginalStackFrame().catch((err: Error) => ({\n    error: true,\n    reason: err?.message ?? err?.toString() ?? 'Unknown Error',\n    external: false,\n    sourceStackFrame: source,\n    originalStackFrame: null,\n    originalCodeFrame: null,\n    sourcePackage: null,\n    ignored: false,\n  }))\n}\n\nexport function getOriginalStackFrames(\n  frames: StackFrame[],\n  type: 'server' | 'edge-server' | null,\n  isAppDir: boolean,\n  errorMessage: string\n) {\n  return Promise.all(\n    frames.map((frame) =>\n      getOriginalStackFrame(frame, type, isAppDir, errorMessage)\n    )\n  )\n}\n\nexport function getFrameSource(frame: StackFrame): string {\n  if (!frame.file) return ''\n\n  const isWebpackFrame = isWebpackInternalResource(frame.file)\n\n  let str = ''\n  // Skip URL parsing for webpack internal file paths.\n  if (isWebpackFrame) {\n    str = formatFrameSourceFile(frame.file)\n  } else {\n    try {\n      const u = new URL(frame.file)\n\n      let parsedPath = ''\n      // Strip the origin for same-origin scripts.\n      if (globalThis.location?.origin !== u.origin) {\n        // URLs can be valid without an `origin`, so long as they have a\n        // `protocol`. However, `origin` is preferred.\n        if (u.origin === 'null') {\n          parsedPath += u.protocol\n        } else {\n          parsedPath += u.origin\n        }\n      }\n\n      // Strip query string information as it's typically too verbose to be\n      // meaningful.\n      parsedPath += u.pathname\n      str = formatFrameSourceFile(parsedPath)\n    } catch {\n      str = formatFrameSourceFile(frame.file)\n    }\n  }\n\n  if (!isWebpackInternalResource(frame.file) && frame.lineNumber != null) {\n    if (str) {\n      if (frame.column != null) {\n        str += ` (${frame.lineNumber}:${frame.column})`\n      } else {\n        str += ` (${frame.lineNumber})`\n      }\n    }\n  }\n  return str\n}\n"],"names":["isWebpackInternalResource","formatFrameSourceFile","getOriginalStackFrame","source","type","isAppDir","errorMessage","_getOriginalStackFrame","body","params","URLSearchParams","append","String","key","toString","controller","AbortController","tm","setTimeout","abort","res","self","fetch","process","env","__NEXT_ROUTER_BASEPATH","signal","finally","clearTimeout","ok","status","Promise","reject","Error","text","json","error","reason","external","sourceStackFrame","originalStackFrame","originalCodeFrame","sourcePackage","ignored","file","match","resolve","catch","err","message","getOriginalStackFrames","frames","all","map","frame","getFrameSource","isWebpackFrame","str","globalThis","u","URL","parsedPath","location","origin","protocol","pathname","lineNumber","column"],"mappings":"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"}