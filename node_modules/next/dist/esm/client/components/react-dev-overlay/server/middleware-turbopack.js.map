{"version":3,"sources":["../../../../../src/client/components/react-dev-overlay/server/middleware-turbopack.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'http'\nimport {\n  badRequest,\n  getOriginalCodeFrame,\n  internalServerError,\n  json,\n  jsonString,\n  noContent,\n  type OriginalStackFrameResponse,\n} from './shared'\n\nimport fs, { constants as FS } from 'fs/promises'\nimport path from 'path'\nimport url from 'url'\nimport { launchEditor } from '../internal/helpers/launchEditor'\nimport type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport { SourceMapConsumer } from 'next/dist/compiled/source-map08'\nimport type { Project, TurbopackStackFrame } from '../../../../build/swc/types'\nimport { getSourceMapFromFile } from '../internal/helpers/get-source-map-from-file'\nimport { findSourceMap, type SourceMapPayload } from 'node:module'\n\nfunction shouldIgnorePath(modulePath: string): boolean {\n  return (\n    modulePath.includes('node_modules') ||\n    // Only relevant for when Next.js is symlinked e.g. in the Next.js monorepo\n    modulePath.includes('next/dist')\n  )\n}\n\ntype IgnorableStackFrame = StackFrame & { ignored: boolean }\n\nconst currentSourcesByFile: Map<string, Promise<string | null>> = new Map()\nexport async function batchedTraceSource(\n  project: Project,\n  frame: TurbopackStackFrame\n): Promise<{ frame: IgnorableStackFrame; source: string | null } | undefined> {\n  const file = frame.file\n    ? // TODO(veil): Why are the frames sent encoded?\n      decodeURIComponent(frame.file)\n    : undefined\n  if (!file) return\n\n  const sourceFrame = await project.traceSource(frame)\n  if (!sourceFrame) {\n    return {\n      frame: {\n        file,\n        lineNumber: frame.line ?? 0,\n        column: frame.column ?? 0,\n        methodName: frame.methodName ?? '<unknown>',\n        ignored: shouldIgnorePath(frame.file),\n        arguments: [],\n      },\n      source: null,\n    }\n  }\n\n  let source = null\n  // Don't look up source for node_modules or internals. These can often be large bundled files.\n  const ignored =\n    shouldIgnorePath(sourceFrame.file) ||\n    // isInternal means resource starts with turbopack://[turbopack]\n    !!sourceFrame.isInternal\n  if (sourceFrame && sourceFrame.file && !ignored) {\n    let sourcePromise = currentSourcesByFile.get(sourceFrame.file)\n    if (!sourcePromise) {\n      sourcePromise = project.getSourceForAsset(sourceFrame.file)\n      currentSourcesByFile.set(sourceFrame.file, sourcePromise)\n      setTimeout(() => {\n        // Cache file reads for 100ms, as frames will often reference the same\n        // files and can be large.\n        currentSourcesByFile.delete(sourceFrame.file!)\n      }, 100)\n    }\n    source = await sourcePromise\n  }\n\n  // TODO: get ignoredList from turbopack source map\n  const ignorableFrame = {\n    file: sourceFrame.file,\n    lineNumber: sourceFrame.line ?? 0,\n    column: sourceFrame.column ?? 0,\n    methodName: sourceFrame.methodName ?? frame.methodName ?? '<unknown>',\n    ignored,\n    arguments: [],\n  }\n\n  return {\n    frame: ignorableFrame,\n    source,\n  }\n}\n\nfunction createStackFrame(searchParams: URLSearchParams) {\n  const fileParam = searchParams.get('file')\n\n  if (!fileParam) {\n    return undefined\n  }\n\n  // rsc://React/Server/file://<filename>?42 => file://<filename>\n  const file = fileParam\n    .replace(/^rsc:\\/\\/React\\/[^/]+\\//, '')\n    .replace(/\\?\\d+$/, '')\n\n  return {\n    file,\n    methodName: searchParams.get('methodName') ?? '<unknown>',\n    line: parseInt(searchParams.get('lineNumber') ?? '0', 10) || 0,\n    column: parseInt(searchParams.get('column') ?? '0', 10) || 0,\n    isServer: searchParams.get('isServer') === 'true',\n  } satisfies TurbopackStackFrame\n}\n\n/**\n * https://tc39.es/source-map/#index-map\n */\ninterface IndexSourceMapSection {\n  offset: {\n    line: number\n    column: number\n  }\n  map: ModernRawSourceMap\n}\n\n// TODO(veil): Upstream types\ninterface IndexSourceMap {\n  version: number\n  file: string\n  sections: IndexSourceMapSection[]\n}\n\ninterface ModernRawSourceMap extends SourceMapPayload {\n  ignoreList?: number[]\n}\n\ntype ModernSourceMapPayload = ModernRawSourceMap | IndexSourceMap\n\n/**\n * Finds the sourcemap payload applicable to a given frame.\n * Equal to the input unless an Index Source Map is used.\n */\nfunction findApplicableSourceMapPayload(\n  frame: TurbopackStackFrame,\n  payload: ModernSourceMapPayload\n): ModernRawSourceMap | undefined {\n  if ('sections' in payload) {\n    const frameLine = frame.line ?? 0\n    const frameColumn = frame.column ?? 0\n    // Sections must not overlap and must be sorted: https://tc39.es/source-map/#section-object\n    // Therefore the last section that has an offset less than or equal to the frame is the applicable one.\n    // TODO(veil): Binary search\n    let section: IndexSourceMapSection | undefined = payload.sections[0]\n    for (\n      let i = 0;\n      i < payload.sections.length &&\n      payload.sections[i].offset.line <= frameLine &&\n      payload.sections[i].offset.column <= frameColumn;\n      i++\n    ) {\n      section = payload.sections[i]\n    }\n\n    return section === undefined ? undefined : section.map\n  } else {\n    return payload\n  }\n}\n\nasync function nativeTraceSource(\n  frame: TurbopackStackFrame\n): Promise<{ frame: IgnorableStackFrame; source: string | null } | undefined> {\n  const sourceMap = findSourceMap(\n    // TODO(veil): Why are the frames sent encoded?\n    decodeURIComponent(frame.file)\n  )\n  if (sourceMap !== undefined) {\n    const traced = await SourceMapConsumer.with(\n      sourceMap.payload,\n      null,\n      async (consumer) => {\n        const originalPosition = consumer.originalPositionFor({\n          line: frame.line ?? 1,\n          column: frame.column ?? 1,\n        })\n\n        if (originalPosition.source === null) {\n          return null\n        }\n\n        const sourceContent: string | null =\n          consumer.sourceContentFor(\n            originalPosition.source,\n            /* returnNullOnMissing */ true\n          ) ?? null\n\n        return { originalPosition, sourceContent }\n      }\n    )\n\n    if (traced !== null) {\n      const { originalPosition, sourceContent } = traced\n      const applicableSourceMap = findApplicableSourceMapPayload(\n        frame,\n        sourceMap.payload\n      )\n\n      // TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.\n      let ignored = false\n      if (applicableSourceMap === undefined) {\n        console.error(\n          'No applicable source map found in sections for frame',\n          frame\n        )\n      } else {\n        // TODO: O(n^2). Consider moving `ignoreList` into a Set\n        const sourceIndex = applicableSourceMap.sources.indexOf(\n          originalPosition.source!\n        )\n        ignored = applicableSourceMap.ignoreList?.includes(sourceIndex) ?? false\n      }\n\n      const originalStackFrame: IgnorableStackFrame = {\n        methodName:\n          originalPosition.name ||\n          // default is not a valid identifier in JS so webpack uses a custom variable when it's an unnamed default export\n          // Resolve it back to `default` for the method name if the source position didn't have the method.\n          frame.methodName\n            ?.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')\n            ?.replace('__webpack_exports__.', '') ||\n          '<unknown>',\n        column: (originalPosition.column ?? 0) + 1,\n        file: originalPosition.source?.startsWith('file://')\n          ? path.relative(\n              process.cwd(),\n              url.fileURLToPath(originalPosition.source)\n            )\n          : originalPosition.source,\n        lineNumber: originalPosition.line ?? 0,\n        // TODO: c&p from async createOriginalStackFrame but why not frame.arguments?\n        arguments: [],\n        ignored,\n      }\n\n      return {\n        frame: originalStackFrame,\n        source: sourceContent,\n      }\n    }\n  }\n\n  return undefined\n}\n\nasync function createOriginalStackFrame(\n  project: Project,\n  frame: TurbopackStackFrame\n): Promise<OriginalStackFrameResponse | null> {\n  const traced =\n    (await nativeTraceSource(frame)) ??\n    // TODO(veil): When would the bundler know more than native?\n    // If it's faster, try the bundler first and fall back to native later.\n    (await batchedTraceSource(project, frame))\n  if (!traced) {\n    return null\n  }\n\n  return {\n    originalStackFrame: traced.frame,\n    originalCodeFrame: getOriginalCodeFrame(traced.frame, traced.source),\n  }\n}\n\nexport function getOverlayMiddleware(project: Project) {\n  return async function (\n    req: IncomingMessage,\n    res: ServerResponse,\n    next: () => void\n  ): Promise<void> {\n    const { pathname, searchParams } = new URL(req.url!, 'http://n')\n\n    if (pathname === '/__nextjs_original-stack-frame') {\n      const frame = createStackFrame(searchParams)\n\n      if (!frame) return badRequest(res)\n\n      let originalStackFrame: OriginalStackFrameResponse | null\n      try {\n        originalStackFrame = await createOriginalStackFrame(project, frame)\n      } catch (e: any) {\n        return internalServerError(res, e.message)\n      }\n\n      if (!originalStackFrame) {\n        res.statusCode = 404\n        res.end('Unable to resolve sourcemap')\n        return\n      }\n\n      return json(res, originalStackFrame)\n    } else if (pathname === '/__nextjs_launch-editor') {\n      const frame = createStackFrame(searchParams)\n\n      if (!frame) return badRequest(res)\n\n      const fileExists = await fs.access(frame.file, FS.F_OK).then(\n        () => true,\n        () => false\n      )\n      if (!fileExists) return noContent(res)\n\n      try {\n        launchEditor(frame.file, frame.line ?? 1, frame.column ?? 1)\n      } catch (err) {\n        console.log('Failed to launch editor:', err)\n        return internalServerError(res)\n      }\n\n      noContent(res)\n    }\n\n    return next()\n  }\n}\n\nexport function getSourceMapMiddleware(project: Project) {\n  return async function (\n    req: IncomingMessage,\n    res: ServerResponse,\n    next: () => void\n  ): Promise<void> {\n    const { pathname, searchParams } = new URL(req.url!, 'http://n')\n\n    if (pathname !== '/__nextjs_source-map') {\n      return next()\n    }\n\n    let filename = searchParams.get('filename')\n\n    if (!filename) {\n      return badRequest(res)\n    }\n\n    // TODO(veil): Always try the native version first.\n    // Externals could also be files that aren't bundled via Webpack.\n    if (\n      filename.startsWith('webpack://') ||\n      filename.startsWith('webpack-internal:///')\n    ) {\n      const sourceMap = findSourceMap(filename)\n\n      if (sourceMap) {\n        return json(res, sourceMap.payload)\n      }\n\n      return noContent(res)\n    }\n\n    try {\n      // Turbopack chunk filenames might be URL-encoded.\n      filename = decodeURI(filename)\n\n      if (path.isAbsolute(filename)) {\n        filename = url.pathToFileURL(filename).href\n      }\n\n      const sourceMapString = await project.getSourceMap(filename)\n\n      if (sourceMapString) {\n        return jsonString(res, sourceMapString)\n      }\n\n      if (filename.startsWith('file:')) {\n        const sourceMap = await getSourceMapFromFile(filename)\n\n        if (sourceMap) {\n          return json(res, sourceMap)\n        }\n      }\n    } catch (error) {\n      console.error('Failed to get source map:', error)\n    }\n\n    noContent(res)\n  }\n}\n"],"names":["badRequest","getOriginalCodeFrame","internalServerError","json","jsonString","noContent","fs","constants","FS","path","url","launchEditor","SourceMapConsumer","getSourceMapFromFile","findSourceMap","shouldIgnorePath","modulePath","includes","currentSourcesByFile","Map","batchedTraceSource","project","frame","file","decodeURIComponent","undefined","sourceFrame","traceSource","lineNumber","line","column","methodName","ignored","arguments","source","isInternal","sourcePromise","get","getSourceForAsset","set","setTimeout","delete","ignorableFrame","createStackFrame","searchParams","fileParam","replace","parseInt","isServer","findApplicableSourceMapPayload","payload","frameLine","frameColumn","section","sections","i","length","offset","map","nativeTraceSource","sourceMap","traced","with","consumer","originalPosition","originalPositionFor","sourceContent","sourceContentFor","applicableSourceMap","console","error","sourceIndex","sources","indexOf","ignoreList","originalStackFrame","name","startsWith","relative","process","cwd","fileURLToPath","createOriginalStackFrame","originalCodeFrame","getOverlayMiddleware","req","res","next","pathname","URL","e","message","statusCode","end","fileExists","access","F_OK","then","err","log","getSourceMapMiddleware","filename","decodeURI","isAbsolute","pathToFileURL","href","sourceMapString","getSourceMap"],"mappings":"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"}