{"version":3,"sources":["../../src/lib/generate-interception-routes-rewrites.ts"],"sourcesContent":["import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'\nimport { NEXT_URL } from '../client/components/app-router-headers'\nimport {\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n} from '../server/lib/interception-routes'\nimport type { Rewrite } from './load-custom-routes'\n\n// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)\nfunction toPathToRegexpPath(path: string): string {\n  return path.replace(/\\[\\[?([^\\]]+)\\]\\]?/g, (_, capture) => {\n    // path-to-regexp only supports word characters, so we replace any non-word characters with underscores\n    const paramName = capture.replace(/\\W+/g, '_')\n\n    // handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])\n    if (capture.startsWith('...')) {\n      return `:${capture.slice(3)}*`\n    }\n    return ':' + paramName\n  })\n}\n\nexport function generateInterceptionRoutesRewrites(\n  appPaths: string[],\n  basePath = ''\n): Rewrite[] {\n  const rewrites: Rewrite[] = []\n\n  for (const appPath of appPaths) {\n    if (isInterceptionRouteAppPath(appPath)) {\n      const { interceptingRoute, interceptedRoute } =\n        extractInterceptionRouteInformation(appPath)\n\n      const normalizedInterceptingRoute = `${\n        interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''\n      }/(.*)?`\n\n      const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute)\n      const normalizedAppPath = toPathToRegexpPath(appPath)\n\n      // pathToRegexp returns a regex that matches the path, but we need to\n      // convert it to a string that can be used in a header value\n      // to the format that Next/the proxy expects\n      let interceptingRouteRegex = pathToRegexp(normalizedInterceptingRoute)\n        .toString()\n        .slice(2, -3)\n\n      rewrites.push({\n        source: `${basePath}${normalizedInterceptedRoute}`,\n        destination: `${basePath}${normalizedAppPath}`,\n        has: [\n          {\n            type: 'header',\n            key: NEXT_URL,\n            value: interceptingRouteRegex,\n          },\n        ],\n      })\n    }\n  }\n\n  return rewrites\n}\n\nexport function isInterceptionRouteRewrite(route: Rewrite) {\n  // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n  return route.has?.[0]?.key === NEXT_URL\n}\n"],"names":["pathToRegexp","NEXT_URL","extractInterceptionRouteInformation","isInterceptionRouteAppPath","toPathToRegexpPath","path","replace","_","capture","paramName","startsWith","slice","generateInterceptionRoutesRewrites","appPaths","basePath","rewrites","appPath","interceptingRoute","interceptedRoute","normalizedInterceptingRoute","normalizedInterceptedRoute","normalizedAppPath","interceptingRouteRegex","toString","push","source","destination","has","type","key","value","isInterceptionRouteRewrite","route"],"mappings":"AAAA,SAASA,YAAY,QAAQ,oCAAmC;AAChE,SAASC,QAAQ,QAAQ,0CAAyC;AAClE,SACEC,mCAAmC,EACnCC,0BAA0B,QACrB,oCAAmC;AAG1C,iIAAiI;AACjI,SAASC,mBAAmBC,IAAY;IACtC,OAAOA,KAAKC,OAAO,CAAC,uBAAuB,CAACC,GAAGC;QAC7C,uGAAuG;QACvG,MAAMC,YAAYD,QAAQF,OAAO,CAAC,QAAQ;QAE1C,4EAA4E;QAC5E,IAAIE,QAAQE,UAAU,CAAC,QAAQ;YAC7B,OAAO,CAAC,CAAC,EAAEF,QAAQG,KAAK,CAAC,GAAG,CAAC,CAAC;QAChC;QACA,OAAO,MAAMF;IACf;AACF;AAEA,OAAO,SAASG,mCACdC,QAAkB,EAClBC,WAAW,EAAE;IAEb,MAAMC,WAAsB,EAAE;IAE9B,KAAK,MAAMC,WAAWH,SAAU;QAC9B,IAAIV,2BAA2Ba,UAAU;YACvC,MAAM,EAAEC,iBAAiB,EAAEC,gBAAgB,EAAE,GAC3ChB,oCAAoCc;YAEtC,MAAMG,8BAA8B,GAClCF,sBAAsB,MAAMb,mBAAmBa,qBAAqB,GACrE,MAAM,CAAC;YAER,MAAMG,6BAA6BhB,mBAAmBc;YACtD,MAAMG,oBAAoBjB,mBAAmBY;YAE7C,qEAAqE;YACrE,4DAA4D;YAC5D,4CAA4C;YAC5C,IAAIM,yBAAyBtB,aAAamB,6BACvCI,QAAQ,GACRZ,KAAK,CAAC,GAAG,CAAC;YAEbI,SAASS,IAAI,CAAC;gBACZC,QAAQ,GAAGX,WAAWM,4BAA4B;gBAClDM,aAAa,GAAGZ,WAAWO,mBAAmB;gBAC9CM,KAAK;oBACH;wBACEC,MAAM;wBACNC,KAAK5B;wBACL6B,OAAOR;oBACT;iBACD;YACH;QACF;IACF;IAEA,OAAOP;AACT;AAEA,OAAO,SAASgB,2BAA2BC,KAAc;QAEhDA,aAAAA;IADP,0HAA0H;IAC1H,OAAOA,EAAAA,aAAAA,MAAML,GAAG,sBAATK,cAAAA,UAAW,CAAC,EAAE,qBAAdA,YAAgBH,GAAG,MAAK5B;AACjC"}