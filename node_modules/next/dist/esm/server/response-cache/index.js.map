{"version":3,"sources":["../../../src/server/response-cache/index.ts"],"sourcesContent":["import {\n  type IncrementalCache,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n  type IncrementalCacheItem,\n  type ResponseCacheBase,\n  CachedRouteKind,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly batcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalCacheItem | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalCacheItem | null\n    expiresAt: number\n  }\n\n  private minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n  }\n\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({ hasResolved: false, previousCacheEntry: null })\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n    } = context\n\n    const response = await this.batcher.batch(\n      { key, isOnDemandRevalidate },\n      async (cacheKey, resolve) => {\n        // We keep the previous cache entry around to leverage when the\n        // incremental cache is disabled in minimal mode.\n        if (\n          this.minimalMode &&\n          this.previousCacheItem?.key === cacheKey &&\n          this.previousCacheItem.expiresAt > Date.now()\n        ) {\n          return this.previousCacheItem.entry\n        }\n\n        // Coerce the kindHint into a given kind for the incremental cache.\n        const kind = routeKindToIncrementalCacheKind(context.routeKind)\n\n        let resolved = false\n        let cachedResponse: IncrementalCacheItem = null\n        try {\n          cachedResponse = !this.minimalMode\n            ? await incrementalCache.get(key, {\n                kind,\n                isRoutePPREnabled: context.isRoutePPREnabled,\n                isFallback,\n              })\n            : null\n\n          if (cachedResponse && !isOnDemandRevalidate) {\n            if (cachedResponse.value?.kind === CachedRouteKind.FETCH) {\n              throw new Error(\n                `invariant: unexpected cachedResponse of kind fetch in response cache`\n              )\n            }\n\n            resolve({\n              ...cachedResponse,\n              revalidate: cachedResponse.curRevalidate,\n            })\n            resolved = true\n\n            if (!cachedResponse.isStale || context.isPrefetch) {\n              // The cached value is still valid, so we don't need\n              // to update it yet.\n              return null\n            }\n          }\n\n          const cacheEntry = await responseGenerator({\n            hasResolved: resolved,\n            previousCacheEntry: cachedResponse,\n            isRevalidating: true,\n          })\n\n          // If the cache entry couldn't be generated, we don't want to cache\n          // the result.\n          if (!cacheEntry) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          const resolveValue = await fromResponseCacheEntry({\n            ...cacheEntry,\n            isMiss: !cachedResponse,\n          })\n          if (!resolveValue) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          // For on-demand revalidate wait to resolve until cache is set.\n          // Otherwise resolve now.\n          if (!isOnDemandRevalidate && !resolved) {\n            resolve(resolveValue)\n            resolved = true\n          }\n\n          // We want to persist the result only if it has a revalidate value\n          // defined.\n          if (typeof resolveValue.revalidate !== 'undefined') {\n            if (this.minimalMode) {\n              this.previousCacheItem = {\n                key: cacheKey,\n                entry: resolveValue,\n                expiresAt: Date.now() + 1000,\n              }\n            } else {\n              await incrementalCache.set(key, resolveValue.value, {\n                revalidate: resolveValue.revalidate,\n                isRoutePPREnabled,\n                isFallback,\n              })\n            }\n          }\n\n          return resolveValue\n        } catch (err) {\n          // When a getStaticProps path is erroring we automatically re-set the\n          // existing cache under a new expiration to prevent non-stop retrying.\n          if (cachedResponse) {\n            await incrementalCache.set(key, cachedResponse.value, {\n              revalidate: Math.min(\n                Math.max(cachedResponse.revalidate || 3, 3),\n                30\n              ),\n              isRoutePPREnabled,\n              isFallback,\n            })\n          }\n\n          // While revalidating in the background we can't reject as we already\n          // resolved the cache entry so log the error here.\n          if (resolved) {\n            console.error(err)\n            return null\n          }\n\n          // We haven't resolved yet, so let's throw to indicate an error.\n          throw err\n        }\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n}\n"],"names":["CachedRouteKind","Batcher","scheduleOnNextTick","fromResponseCacheEntry","routeKindToIncrementalCacheKind","toResponseCacheEntry","ResponseCache","constructor","minimalMode","batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","minimalModeKey","get","responseGenerator","context","hasResolved","previousCacheEntry","incrementalCache","isFallback","isRoutePPREnabled","response","batch","cacheKey","resolve","previousCacheItem","expiresAt","Date","now","entry","kind","routeKind","resolved","cachedResponse","value","FETCH","Error","revalidate","curRevalidate","isStale","isPrefetch","cacheEntry","isRevalidating","undefined","resolveValue","isMiss","set","err","Math","min","max","console","error"],"mappings":"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"}