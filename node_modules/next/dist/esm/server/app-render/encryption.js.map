{"version":3,"sources":["../../../src/server/app-render/encryption.ts"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server.edge'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client.edge'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  getClientReferenceManifestForRsc,\n  getServerModuleMap,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\n// Encrypts the action's bound args into a string.\nexport async function encryptActionBoundArgs(actionId: string, args: any[]) {\n  const { clientModules } = getClientReferenceManifestForRsc()\n\n  // Create an error before any asynchrounous calls, to capture the original\n  // call stack in case we need it when the serialization errors.\n  const error = new Error()\n  Error.captureStackTrace(error, encryptActionBoundArgs)\n\n  let didCatchError = false\n\n  // Using Flight to serialize the args into a string.\n  const serialized = await streamToString(\n    renderToReadableStream(args, clientModules, {\n      onError(err) {\n        // We're only reporting one error at a time, starting with the first.\n        if (didCatchError) {\n          return\n        }\n\n        didCatchError = true\n\n        // Use the original error message together with the previously created\n        // stack, because err.stack is a useless Flight Server call stack.\n        error.message = err instanceof Error ? err.message : String(err)\n      },\n    })\n  )\n\n  if (didCatchError) {\n    if (process.env.NODE_ENV === 'development') {\n      // Logging the error is needed for server functions that are passed to the\n      // client where the decryption is not done during rendering. Console\n      // replaying allows us to still show the error dev overlay in this case.\n      console.error(error)\n    }\n\n    throw error\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workUnitStore) {\n    return encodeActionBoundArg(actionId, serialized)\n  }\n\n  const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n  const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n  const cacheKey = actionId + serialized\n\n  const cachedEncrypted =\n    prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n    renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n  if (cachedEncrypted) {\n    return cachedEncrypted\n  }\n\n  const cacheSignal =\n    workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : undefined\n\n  cacheSignal?.beginRead()\n\n  const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n  cacheSignal?.endRead()\n  prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n  return encrypted\n}\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encrypted: Promise<string>\n) {\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifestForRsc()\n\n  // Decrypt the serialized string with the action id as the salt.\n  const decrypted = await decodeActionBoundArg(actionId, await encrypted)\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n        controller.close()\n      },\n    }),\n    {\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n"],"names":["renderToReadableStream","createFromReadableStream","streamToString","arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","getClientReferenceManifestForRsc","getServerModuleMap","stringToUint8Array","getPrerenderResumeDataCache","getRenderResumeDataCache","workUnitAsyncStorage","isEdgeRuntime","process","env","NEXT_RUNTIME","textEncoder","TextEncoder","textDecoder","TextDecoder","decodeActionBoundArg","actionId","arg","key","Error","originalPayload","atob","ivValue","slice","payload","decrypted","decode","startsWith","length","encodeActionBoundArg","undefined","randomBytes","Uint8Array","exit","crypto","getRandomValues","buffer","encrypted","encode","btoa","encryptActionBoundArgs","args","clientModules","error","captureStackTrace","didCatchError","serialized","onError","err","message","String","NODE_ENV","console","workUnitStore","getStore","prerenderResumeDataCache","renderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","get","cacheSignal","type","beginRead","endRead","set","decryptActionBoundArgs","edgeRscModuleMapping","rscModuleMapping","deserialized","ReadableStream","start","controller","enqueue","close","serverConsumerManifest","moduleLoading","moduleMap","serverModuleMap"],"mappings":"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"}