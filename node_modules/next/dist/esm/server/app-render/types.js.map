{"version":3,"sources":["../../../src/server/app-render/types.ts"],"sourcesContent":["import type { LoadComponentsReturnType } from '../load-components'\nimport type { ServerRuntime, SizeLimit } from '../../types'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { ExpireTime } from '../lib/revalidate'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport s from 'next/dist/compiled/superstruct'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { InstrumentationOnRequestError } from '../instrumentation/types'\nimport type { NextRequestHint } from '../web/adapter'\nimport type { BaseNextRequest } from '../base-http'\nimport type { IncomingMessage } from 'http'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted'\n\nconst dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])\n\nexport type DynamicParamTypesShort = s.Infer<typeof dynamicParamTypesSchema>\n\nconst segmentSchema = s.union([\n  s.string(),\n  s.tuple([s.string(), s.string(), dynamicParamTypesSchema]),\n])\n\nexport type Segment = s.Infer<typeof segmentSchema>\n\n// unfortunately the tuple is not understood well by Describe so we have to\n// use any here. This does not have any impact on the runtime type since the validation\n// does work correctly.\nexport const flightRouterStateSchema: s.Describe<any> = s.tuple([\n  segmentSchema,\n  s.record(\n    s.string(),\n    s.lazy(() => flightRouterStateSchema)\n  ),\n  s.optional(s.nullable(s.string())),\n  s.optional(s.nullable(s.union([s.literal('refetch'), s.literal('refresh')]))),\n  s.optional(s.boolean()),\n])\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /*\n  /* \"refresh\" and \"refetch\", despite being similarly named, have different semantics.\n   * - \"refetch\" is a server indicator which informs where rendering should start from.\n   * - \"refresh\" is a client router indicator that it should re-fetch the data from the server for the current segment.\n   *   It uses the \"url\" property above to determine where to fetch from.\n   */\n  refresh?: 'refetch' | 'refresh' | null,\n  isRootLayout?: boolean,\n]\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  segment: Segment,\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head */ React.ReactNode | null,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type ServerOnInstrumentationRequestError = (\n  error: unknown,\n  // The request could be middleware, node server or web server request,\n  // we normalized them into an aligned format to `onRequestError` API later.\n  request: NextRequestHint | BaseNextRequest | IncomingMessage,\n  errorContext: Parameters<InstrumentationOnRequestError>[2]\n) => void | Promise<void>\n\nexport interface RenderOptsPartial {\n  previewProps: __ApiPreviewProps | undefined\n  err?: Error | null\n  dev?: boolean\n  buildId: string\n  basePath: string\n  trailingSlash: boolean\n  clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>\n  supportsDynamicResponse: boolean\n  runtime?: ServerRuntime\n  serverComponents?: boolean\n  enableTainting?: boolean\n  assetPrefix?: string\n  crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined\n  nextFontManifest?: DeepReadonly<NextFontManifest>\n  isBot?: boolean\n  incrementalCache?: import('../lib/incremental-cache').IncrementalCache\n  cacheLifeProfiles?: {\n    [profile: string]: import('../use-cache/cache-life').CacheLife\n  }\n  setAppIsrStatus?: (key: string, value: boolean | null) => void\n  isRevalidate?: boolean\n  nextExport?: boolean\n  nextConfigOutput?: 'standalone' | 'export'\n  onInstrumentationRequestError?: ServerOnInstrumentationRequestError\n  isDraftMode?: boolean\n  deploymentId?: string\n  onUpdateCookies?: (cookies: string[]) => void\n  loadConfig?: (\n    phase: string,\n    dir: string,\n    customConfig?: object | null,\n    rawConfig?: boolean,\n    silent?: boolean\n  ) => Promise<NextConfigComplete>\n  serverActions?: {\n    bodySizeLimit?: SizeLimit\n    allowedOrigins?: string[]\n  }\n  params?: ParsedUrlQuery\n  isPrefetch?: boolean\n  experimental: {\n    /**\n     * When true, it indicates that the current page supports partial\n     * prerendering.\n     */\n    isRoutePPREnabled?: boolean\n    expireTime: ExpireTime | undefined\n    clientTraceMetadata: string[] | undefined\n    dynamicIO: boolean\n    inlineCss: boolean\n    authInterrupts: boolean\n  }\n  postponed?: string\n\n  /**\n   * The resume data cache that was generated for this partially prerendered\n   * page during dev warmup.\n   */\n  devRenderResumeDataCache?: RenderResumeDataCache\n\n  /**\n   * When true, only the static shell of the page will be rendered. This will\n   * also enable other debugging features such as logging in development.\n   */\n  isDebugStaticShell?: boolean\n\n  /**\n   * When true, the page will be rendered using the static rendering to detect\n   * any dynamic API's that would have stopped the page from being fully\n   * statically generated.\n   */\n  isDebugDynamicAccesses?: boolean\n\n  /**\n   * The maximum length of the headers that are emitted by React and added to\n   * the response.\n   */\n  reactMaxHeadersLength: number | undefined\n\n  isStaticGeneration?: boolean\n}\n\nexport type RenderOpts = LoadComponentsReturnType<AppPageModule> &\n  RenderOptsPartial &\n  RequestLifecycleOpts\n\nexport type PreloadCallbacks = (() => void)[]\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** assetPrefix */\n  p: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** postponed */\n  s: boolean\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n"],"names":["s","dynamicParamTypesSchema","enums","segmentSchema","union","string","tuple","flightRouterStateSchema","record","lazy","optional","nullable","literal","boolean"],"mappings":"AAYA,OAAOA,OAAO,iCAAgC;AAe9C,MAAMC,0BAA0BD,EAAEE,KAAK,CAAC;IAAC;IAAK;IAAM;IAAM;IAAK;CAAK;AAIpE,MAAMC,gBAAgBH,EAAEI,KAAK,CAAC;IAC5BJ,EAAEK,MAAM;IACRL,EAAEM,KAAK,CAAC;QAACN,EAAEK,MAAM;QAAIL,EAAEK,MAAM;QAAIJ;KAAwB;CAC1D;AAID,2EAA2E;AAC3E,uFAAuF;AACvF,uBAAuB;AACvB,OAAO,MAAMM,0BAA2CP,EAAEM,KAAK,CAAC;IAC9DH;IACAH,EAAEQ,MAAM,CACNR,EAAEK,MAAM,IACRL,EAAES,IAAI,CAAC,IAAMF;IAEfP,EAAEU,QAAQ,CAACV,EAAEW,QAAQ,CAACX,EAAEK,MAAM;IAC9BL,EAAEU,QAAQ,CAACV,EAAEW,QAAQ,CAACX,EAAEI,KAAK,CAAC;QAACJ,EAAEY,OAAO,CAAC;QAAYZ,EAAEY,OAAO,CAAC;KAAW;IAC1EZ,EAAEU,QAAQ,CAACV,EAAEa,OAAO;CACrB,EAAC"}