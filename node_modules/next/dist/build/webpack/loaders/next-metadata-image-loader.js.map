{"version":3,"sources":["../../../../src/build/webpack/loaders/next-metadata-image-loader.ts"],"sourcesContent":["/*\n * This loader is responsible for extracting the metadata image info for rendering in html\n */\n\nimport type webpack from 'webpack'\nimport type {\n  MetadataImageModule,\n  PossibleImageFileNameConvention,\n} from './metadata/types'\nimport { existsSync, promises as fs } from 'fs'\nimport path from 'path'\nimport loaderUtils from 'next/dist/compiled/loader-utils3'\nimport { getImageSize } from '../../../server/image-optimizer'\nimport { imageExtMimeTypeMap } from '../../../lib/mime-type'\nimport { WEBPACK_RESOURCE_QUERIES } from '../../../lib/constants'\nimport { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep'\nimport type { PageExtensions } from '../../page-extensions-type'\nimport { getLoaderModuleNamedExports } from './utils'\n\ninterface Options {\n  segment: string\n  type: PossibleImageFileNameConvention\n  pageExtensions: PageExtensions\n  basePath: string\n}\n\n// [NOTE] For turbopack, refer to app_page_loader_tree's write_metadata_item for\n// corresponding features.\nasync function nextMetadataImageLoader(\n  this: webpack.LoaderContext<Options>,\n  content: Buffer\n) {\n  const options: Options = this.getOptions()\n  const { type, segment, pageExtensions, basePath } = options\n  const { resourcePath, rootContext: context } = this\n  const { name: fileNameBase, ext } = path.parse(resourcePath)\n  const useNumericSizes = type === 'twitter' || type === 'openGraph'\n\n  let extension = ext.slice(1)\n  if (extension === 'jpg') {\n    extension = 'jpeg'\n  }\n\n  const opts = { context, content }\n\n  // No hash query for favicon.ico\n  const contentHash =\n    type === 'favicon'\n      ? ''\n      : loaderUtils.interpolateName(this, '[contenthash]', opts)\n\n  const interpolatedName = loaderUtils.interpolateName(\n    this,\n    '[name].[ext]',\n    opts\n  )\n\n  const isDynamicResource = pageExtensions.includes(extension)\n  const pageSegment = isDynamicResource ? fileNameBase : interpolatedName\n  const hashQuery = contentHash ? '?' + contentHash : ''\n  const pathnamePrefix = normalizePathSep(path.join(basePath, segment))\n\n  if (isDynamicResource) {\n    const exportedFieldsExcludingDefault = (\n      await getLoaderModuleNamedExports(resourcePath, this)\n    ).filter((name) => name !== 'default')\n\n    // re-export and spread as `exportedImageData` to avoid non-exported error\n    return `\\\n    import {\n      ${exportedFieldsExcludingDefault\n        .map((field) => `${field} as _${field}`)\n        .join(',')}\n    } from ${JSON.stringify(\n      // This is an arbitrary resource query to ensure it's a new request, instead\n      // of sharing the same module with next-metadata-route-loader.\n      // Since here we only need export fields such as `size`, `alt` and\n      // `generateImageMetadata`, avoid sharing the same module can make this entry\n      // smaller.\n      resourcePath + '?' + WEBPACK_RESOURCE_QUERIES.metadataImageMeta\n    )}\n    import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n    const imageModule = {\n      ${exportedFieldsExcludingDefault\n        .map((field) => `${field}: _${field}`)\n        .join(',')}\n    }\n\n    export default async function (props) {\n      const { __metadata_id__: _, ...params } = await props.params\n      const imageUrl = fillMetadataSegment(${JSON.stringify(\n        pathnamePrefix\n      )}, params, ${JSON.stringify(pageSegment)})\n\n      const { generateImageMetadata } = imageModule\n\n      function getImageMetadata(imageMetadata, idParam) {\n        const data = {\n          alt: imageMetadata.alt,\n          type: imageMetadata.contentType || 'image/png',\n          url: imageUrl + (idParam ? ('/' + idParam) : '') + ${JSON.stringify(\n            hashQuery\n          )},\n        }\n        const { size } = imageMetadata\n        if (size) {\n          ${\n            type === 'twitter' || type === 'openGraph'\n              ? 'data.width = size.width; data.height = size.height;'\n              : 'data.sizes = size.width + \"x\" + size.height;'\n          }\n        }\n        return data\n      }\n\n      if (generateImageMetadata) {\n        const imageMetadataArray = await generateImageMetadata({ params })\n        return imageMetadataArray.map((imageMetadata, index) => {\n          const idParam = (imageMetadata.id || index) + ''\n          return getImageMetadata(imageMetadata, idParam)\n        })\n      } else {\n        return [getImageMetadata(imageModule, '')]\n      }\n    }`\n  }\n\n  const imageSize: { width?: number; height?: number } = await getImageSize(\n    content\n  ).catch((err) => err)\n\n  if (imageSize instanceof Error) {\n    const err = imageSize\n    err.name = 'InvalidImageFormatError'\n    throw err\n  }\n\n  const imageData: Omit<MetadataImageModule, 'url'> = {\n    ...(extension in imageExtMimeTypeMap && {\n      type: imageExtMimeTypeMap[extension as keyof typeof imageExtMimeTypeMap],\n    }),\n    ...(useNumericSizes && imageSize.width != null && imageSize.height != null\n      ? imageSize\n      : {\n          sizes:\n            // For SVGs, skip sizes and use \"any\" to let it scale automatically based on viewport,\n            // For the images doesn't provide the size properly, use \"any\" as well.\n            // If the size is presented, use the actual size for the image.\n            extension !== 'svg' &&\n            imageSize.width != null &&\n            imageSize.height != null\n              ? `${imageSize.width}x${imageSize.height}`\n              : 'any',\n        }),\n  }\n  if (type === 'openGraph' || type === 'twitter') {\n    const altPath = path.join(\n      path.dirname(resourcePath),\n      fileNameBase + '.alt.txt'\n    )\n\n    if (existsSync(altPath)) {\n      imageData.alt = await fs.readFile(altPath, 'utf8')\n    }\n  }\n\n  return `\\\n  import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n  export default async (props) => {\n    const imageData = ${JSON.stringify(imageData)}\n    const imageUrl = fillMetadataSegment(${JSON.stringify(\n      pathnamePrefix\n    )}, await props.params, ${JSON.stringify(pageSegment)})\n\n    return [{\n      ...imageData,\n      url: imageUrl + ${JSON.stringify(type === 'favicon' ? '' : hashQuery)},\n    }]\n  }`\n}\n\nexport const raw = true\nexport default nextMetadataImageLoader\n"],"names":["raw","nextMetadataImageLoader","content","options","getOptions","type","segment","pageExtensions","basePath","resourcePath","rootContext","context","name","fileNameBase","ext","path","parse","useNumericSizes","extension","slice","opts","contentHash","loaderUtils","interpolateName","interpolatedName","isDynamicResource","includes","pageSegment","hashQuery","pathnamePrefix","normalizePathSep","join","exportedFieldsExcludingDefault","getLoaderModuleNamedExports","filter","map","field","JSON","stringify","WEBPACK_RESOURCE_QUERIES","metadataImageMeta","imageSize","getImageSize","catch","err","Error","imageData","imageExtMimeTypeMap","width","height","sizes","altPath","dirname","existsSync","alt","fs","readFile"],"mappings":"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"}