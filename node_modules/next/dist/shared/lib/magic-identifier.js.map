{"version":3,"sources":["../../../src/shared/lib/magic-identifier.ts"],"sourcesContent":["function decodeHex(hexStr: string): string {\n  if (hexStr.trim() === '') {\n    throw new Error(\"can't decode empty hex\")\n  }\n\n  const num = parseInt(hexStr, 16)\n  if (isNaN(num)) {\n    throw new Error(`invalid hex: \\`${hexStr}\\``)\n  }\n\n  return String.fromCodePoint(num)\n}\n\nconst enum Mode {\n  Text,\n  Underscore,\n  Hex,\n  LongHex,\n}\n\nconst DECODE_REGEX = /^__TURBOPACK__([a-zA-Z0-9_$]+)__$/\n\nexport function decodeMagicIdentifier(identifier: string): string {\n  const matches = identifier.match(DECODE_REGEX)\n  if (!matches) {\n    return identifier\n  }\n\n  const inner = matches[1]\n\n  let output = ''\n\n  let mode: Mode = Mode.Text\n  let buffer = ''\n  for (let i = 0; i < inner.length; i++) {\n    const char = inner[i]\n\n    if (mode === Mode.Text) {\n      if (char === '_') {\n        mode = Mode.Underscore\n      } else if (char === '$') {\n        mode = Mode.Hex\n      } else {\n        output += char\n      }\n    } else if (mode === Mode.Underscore) {\n      if (char === '_') {\n        output += ' '\n        mode = Mode.Text\n      } else if (char === '$') {\n        output += '_'\n        mode = Mode.Hex\n      } else {\n        output += char\n        mode = Mode.Text\n      }\n    } else if (mode === Mode.Hex) {\n      if (buffer.length === 2) {\n        output += decodeHex(buffer)\n        buffer = ''\n      }\n\n      if (char === '_') {\n        if (buffer !== '') {\n          throw new Error(`invalid hex: \\`${buffer}\\``)\n        }\n\n        mode = Mode.LongHex\n      } else if (char === '$') {\n        if (buffer !== '') {\n          throw new Error(`invalid hex: \\`${buffer}\\``)\n        }\n\n        mode = Mode.Text\n      } else {\n        buffer += char\n      }\n    } else if (mode === Mode.LongHex) {\n      if (char === '_') {\n        throw new Error(`invalid hex: \\`${buffer + char}\\``)\n      } else if (char === '$') {\n        output += decodeHex(buffer)\n        buffer = ''\n\n        mode = Mode.Text\n      } else {\n        buffer += char\n      }\n    }\n  }\n\n  return output\n}\n\nexport const MAGIC_IDENTIFIER_REGEX = /__TURBOPACK__[a-zA-Z0-9_$]+__/g\n"],"names":["MAGIC_IDENTIFIER_REGEX","decodeMagicIdentifier","decodeHex","hexStr","trim","Error","num","parseInt","isNaN","String","fromCodePoint","DECODE_REGEX","identifier","matches","match","inner","output","mode","buffer","i","length","char"],"mappings":";;;;;;;;;;;;;;;IA8FaA,sBAAsB;eAAtBA;;IAxEGC,qBAAqB;eAArBA;;;AAtBhB,SAASC,UAAUC,MAAc;IAC/B,IAAIA,OAAOC,IAAI,OAAO,IAAI;QACxB,MAAM,IAAIC,MAAM;IAClB;IAEA,MAAMC,MAAMC,SAASJ,QAAQ;IAC7B,IAAIK,MAAMF,MAAM;QACd,MAAM,IAAID,MAAM,AAAC,mBAAiBF,SAAO;IAC3C;IAEA,OAAOM,OAAOC,aAAa,CAACJ;AAC9B;AASA,MAAMK,eAAe;AAEd,SAASV,sBAAsBW,UAAkB;IACtD,MAAMC,UAAUD,WAAWE,KAAK,CAACH;IACjC,IAAI,CAACE,SAAS;QACZ,OAAOD;IACT;IAEA,MAAMG,QAAQF,OAAO,CAAC,EAAE;IAExB,IAAIG,SAAS;IAEb,IAAIC;IACJ,IAAIC,SAAS;IACb,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,MAAMK,MAAM,EAAED,IAAK;QACrC,MAAME,OAAON,KAAK,CAACI,EAAE;QAErB,IAAIF,YAAoB;YACtB,IAAII,SAAS,KAAK;gBAChBJ;YACF,OAAO,IAAII,SAAS,KAAK;gBACvBJ;YACF,OAAO;gBACLD,UAAUK;YACZ;QACF,OAAO,IAAIJ,YAA0B;YACnC,IAAII,SAAS,KAAK;gBAChBL,UAAU;gBACVC;YACF,OAAO,IAAII,SAAS,KAAK;gBACvBL,UAAU;gBACVC;YACF,OAAO;gBACLD,UAAUK;gBACVJ;YACF;QACF,OAAO,IAAIA,YAAmB;YAC5B,IAAIC,OAAOE,MAAM,KAAK,GAAG;gBACvBJ,UAAUd,UAAUgB;gBACpBA,SAAS;YACX;YAEA,IAAIG,SAAS,KAAK;gBAChB,IAAIH,WAAW,IAAI;oBACjB,MAAM,IAAIb,MAAM,AAAC,mBAAiBa,SAAO;gBAC3C;gBAEAD;YACF,OAAO,IAAII,SAAS,KAAK;gBACvB,IAAIH,WAAW,IAAI;oBACjB,MAAM,IAAIb,MAAM,AAAC,mBAAiBa,SAAO;gBAC3C;gBAEAD;YACF,OAAO;gBACLC,UAAUG;YACZ;QACF,OAAO,IAAIJ,YAAuB;YAChC,IAAII,SAAS,KAAK;gBAChB,MAAM,IAAIhB,MAAM,AAAC,mBAAiBa,CAAAA,SAASG,IAAG,IAAE;YAClD,OAAO,IAAIA,SAAS,KAAK;gBACvBL,UAAUd,UAAUgB;gBACpBA,SAAS;gBAETD;YACF,OAAO;gBACLC,UAAUG;YACZ;QACF;IACF;IAEA,OAAOL;AACT;AAEO,MAAMhB,yBAAyB"}